---
title: "삼성자산운용 FunETF"
description: "Amcharts 기반 전체 차트 시스템 리뉴얼 및 React 관리자 페이지 개발. 대용량 데이터셋 렌더링 최적화를 수행했습니다."
tags: ["JavaScript", "Amcharts5", "React", "React Query", "Tailwind CSS"]
year: 2024
period: "2024.01 — 2024.05"
links:
  live: "https://www.funetf.co.kr/"
---

## 프로젝트 개요

삼성자산운용 FunETF 서비스의 프론트 차트 작업 및 관리자 페이지 개발을 매니저로서 담당했습니다. 레거시 차트를 Amcharts5로 마이그레이션하고, React 기반 관리자 인터페이스를 새롭게 구축했습니다.

## 주요 성과

- **Amcharts5 기반 전체 차트 시스템 리뉴얼**, 레거시 차트 마이그레이션 및 성능 향상
- **비동기 데이터 처리 및 lazy loading 적용**으로 초기 로딩 지연 문제 해결
- **React 기반 관리자 페이지 개발**: CSR 및 Tailwind CSS 활용, 차트 데이터 CRUD 인터페이스 구현
- **대용량 데이터셋(1000+ 포인트) 렌더링 최적화** 및 반응형 차트 디자인 적용
- **클라이언트 캐싱 전략(React Query)** 및 코드 스플리팅으로 불필요한 API 호출 감소 및 번들 사이즈 최적화

## 기술적 도전

1000개 이상의 데이터 포인트를 실시간으로 렌더링하면서 부드러운 인터랙션을 유지하기 위해 lazy loading과 캐싱 전략을 적용한 것이 핵심 과제였습니다.

금융 차트는 일반적인 데이터 시각화와 달리 정확성에 대한 요구가 매우 높았습니다. ETF 수익률, NAV(순자산가치), 거래량 등의 데이터가 소수점 이하 자릿수까지 정확하게 표현되어야 했고, 차트 간 시간축 동기화도 필수였습니다. 여러 차트가 동일한 시간 범위를 공유하면서 사용자가 한 차트에서 줌/패닝을 수행하면 다른 차트도 동기화되는 연동 로직을 구현했습니다.

대용량 데이터를 한 번에 로드하면 초기 렌더링에 수 초가 걸리는 문제가 있었습니다. 기간별 데이터 분할 로딩(최근 1개월은 일별, 1년은 주별, 전체는 월별)과 뷰포트 기반 데이터 간소화(화면에 표시할 수 있는 픽셀 수를 초과하는 데이터 포인트는 샘플링)를 적용하여 체감 성능을 개선했습니다.

Amcharts5의 번들 사이즈가 상당히 큰(약 500KB gzipped) 편이었기 때문에, 차트 유형별로 코드 스플리팅을 적용하여 사용자가 실제로 보는 차트 모듈만 로드되도록 했습니다.

## 기술적 의사결정 및 근거

### 차트 라이브러리: Amcharts5 vs D3.js vs Chart.js

**Amcharts5 채택.** 금융 차트 특화 기능(캔들스틱, 비교 차트, 줌/패닝, 시간축 동기화)과 개발 생산성 사이의 균형에서 최적의 선택이었습니다. D3.js는 가장 강력한 저수준 라이브러리이지만, 4개월 일정 내에 20개 이상의 금융 차트를 직접 구현하기에는 리소스가 부족했습니다. Chart.js는 가볍지만(약 60KB) 캔들스틱과 시간축 동기화를 지원하지 않고 1000개 이상의 데이터 포인트에서 성능 한계가 있었습니다. Amcharts5는 Canvas 기반 렌더링으로 대용량 데이터 성능이 우수했고, 번들 사이즈(약 500KB gzip) 문제는 코드 스플리팅으로 보완했습니다.

### 서버 상태 관리: React Query vs SWR

**React Query(TanStack Query) 채택.** 금융 데이터는 차별화된 캐싱 전략이 핵심입니다. 시장 데이터는 장 마감 후 변경되지 않으므로 긴 `staleTime`을 설정하고, 관리자가 수정한 데이터는 즉시 무효화해야 합니다. SWR은 더 가벼운 번들 사이즈(약 4KB vs 약 13KB)를 제공하지만, 캐시 무효화 전략이 React Query만큼 세밀하지 않았습니다. React Query의 `queryKey` 기반 무효화와 `staleTime`/`gcTime` 세밀 제어가 이 요구사항에 정확히 부합했습니다.

### Amcharts5 번들 최적화를 위한 코드 스플리팅

Amcharts5의 번들 사이즈(약 500KB gzip)가 초기 로딩에 직접적인 영향을 주는 문제가 있었습니다. 사용자가 보지 않는 차트 유형까지 모두 다운로드하는 것은 불필요한 비용이므로, 차트 유형별 동적 임포트를 적용하여 각 차트(라인, 캔들스틱, 파이 등)를 별도 청크로 분리했습니다. 초기 로드 시에는 메인 페이지에 보이는 라인 차트만 로드하고, 나머지 차트는 Intersection Observer와 결합하여 사용자가 해당 탭을 클릭하거나 스크롤로 접근할 때 로드하도록 지연 로딩을 적용했습니다.

```typescript
// 차트 유형별 코드 스플리팅 + 기간별 캐싱 전략
const LineChart = lazy(() => import('./charts/LineChart'));

function useETFChartData(etfCode: string, period: ChartPeriod) {
  return useQuery({
    queryKey: ['etf', 'chart', etfCode, period],
    staleTime: getStaleTime(period), // 기간별 캐시 수명 차별화
    select: (data) => downsampleData(data, period), // 뷰포트 크기에 맞게 샘플링
  });
}
```

## 담당 기간

2024.01 - 2024.05 | 프론트엔드 개발 매니저
