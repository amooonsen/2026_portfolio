---
title: "래미안 홈플랫폼 홈닉"
description: "Vue.js 기반 입주민 커뮤니티 웹뷰 개발. Chart.js 관리비 시각화, Lottie.js 마이크로 인터랙션, 웹뷰-네이티브 통신 연동을 구현했습니다."
tags: ["Vue.js", "Vuex", "Axios", "Chart.js", "Lottie.js"]
year: 2023
---

## 프로젝트 개요

래미안 홈플랫폼 통합앱 홈닉의 입주민 커뮤니티 웹뷰 전체 UI를 개발했습니다. 앱 내 핵심 기능 구현부터 웹뷰-네이티브 간 통신 인터페이스 연동까지 담당했습니다.

## 주요 성과

- **Vue.js 기반 입주민 커뮤니티 웹뷰 전체 UI 개발**, 앱 내 핵심 기능 구현
- **Chart.js 활용 관리비 에너지 차트 시각화**, 사용자 에너지 소비 패턴 직관적 이해 개선
- **Vuex 상태 관리 설계**: 컴포넌트 간 데이터 흐름 최적화 및 효율적인 상태 관리 구조 구축
- **LottieJS 활용 마이크로 인터랙션 구현**, 네이티브 앱 수준의 사용자 경험 제공
- **웹뷰-네이티브 간 통신 인터페이스 연동** 및 크로스 플랫폼(iOS/Android) 호환성 확보

## 기술적 도전

웹뷰 환경에서 네이티브 앱과의 양방향 통신을 안정적으로 구현하는 것이 가장 큰 과제였습니다. iOS의 WKWebView와 Android의 WebView는 JavaScript 브릿지 인터페이스 방식이 근본적으로 다릅니다. iOS는 `window.webkit.messageHandlers`를 통해 메시지를 전달하고, Android는 `@JavascriptInterface`로 노출된 네이티브 객체를 직접 호출합니다. 이 차이를 웹뷰 코드에서 하나의 통합 인터페이스로 추상화해야 했습니다.

또한 네이티브에서 웹뷰로의 콜백 타이밍이 플랫폼마다 달라, 비동기 응답 처리 시 Promise 기반의 콜백 큐를 구현하여 플랫폼 차이를 흡수했습니다. 웹뷰 내에서 발생하는 에러가 네이티브 크래시 로그에 나타나지 않는 문제도 있어, 웹뷰 자체적으로 에러 바운더리를 구성하고 네이티브로 에러 상태를 전달하는 체계를 구축했습니다.

Chart.js를 활용한 관리비 시각화에서는 월별 에너지 사용량 데이터의 범위가 세대마다 크게 달라, Y축 스케일을 동적으로 조정하면서도 시각적 비교가 유의미하도록 차트 옵션을 세밀하게 조정하는 작업이 필요했습니다.

## 기술적 의사결정 및 근거

### 웹뷰 프레임워크: Vue.js vs React

**Vue.js 채택.** 기존 홈플랫폼의 다른 웹뷰 모듈이 이미 Vue.js로 구축되어 있었고, 네이티브 팀과 협의된 브릿지 인터페이스 예제 코드도 Vue 기반이었습니다. 팀 내 프론트엔드 인력 대부분이 Vue.js에 익숙한 상황에서 React를 도입하면 온보딩 비용이 증가하고, 기존 공통 컴포넌트와 유틸리티를 재활용할 수 없는 문제가 발생합니다. React의 더 넓은 서드파티 생태계와 타입스크립트 친화성을 포기했지만, 프로젝트 일정 준수와 팀 생산성 측면에서 합리적인 판단이었습니다.

### 인앱 차트 라이브러리: Chart.js vs Amcharts

**Chart.js 채택.** 웹뷰 환경에서의 번들 사이즈가 결정적인 요인이었습니다. Amcharts4는 전체 번들이 약 500KB(gzip) 이상으로 웹뷰 초기 로딩에 직접적인 영향을 주지만, Chart.js는 tree-shaking 적용 시 약 60KB 수준으로 번들링할 수 있었습니다. 홈닉에서 필요한 차트는 월별 관리비 추이(Line), 에너지 사용 비교(Bar), 항목별 비율(Doughnut) 세 가지로, Amcharts의 고급 기능(지리 맵, TreeMap 등)은 불필요했습니다. 터치 기반 줌 인터랙션은 `chartjs-plugin-zoom`으로 보완했지만, Amcharts 대비 커스터마이징에 추가 시간이 소요되는 트레이드오프가 있었습니다.

### 네이티브 브릿지 통신: postMessage vs Custom URL Scheme

**postMessage 기반 브릿지 채택.** Custom URL Scheme(`homenic://action?param=value`)은 양 플랫폼에서 작동하지만, URL 문자열에 데이터를 직렬화해야 하므로 복잡한 객체 전달이 어렵고, 네이티브에서 웹뷰로의 응답 채널이 없어 콜백 처리가 번거롭습니다. postMessage 방식은 JSON 객체를 그대로 전달할 수 있고, 콜백 ID를 포함하여 비동기 응답을 Promise로 래핑할 수 있었습니다. 플랫폼별 분기 처리는 추상화 레이어에서 한 번만 처리하여, 비즈니스 로직에서는 단일 API(`bridge.send(action, payload)`)만 호출하도록 설계했습니다. iOS의 WKWebView에서 `messageHandlers` 등록 타이밍 이슈가 있어, 웹뷰 로드 완료 후 브릿지 초기화를 진행하는 핸드셰이크 과정이 추가로 필요했습니다.

## 담당 기간

2023.02 - 2023.12 | 프론트엔드 개발 매니저
